<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Three.JS: Geometry - Extrude</title>
  <link rel="apple-touch-icon" sizes="180x180" href="../../images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../../images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../../images/favicon/favicon-16x16.png">
  <link rel="manifest" href="../../site.webmanifest">
  <style>
    body{
      padding: 0;
      margin: 0;
    }
  </style>
</head>
<body>
<!--
  "three": "https://unpkg.com/three@0.145.0/build/three.module.js",             
  "three/addons/":"https://unpkg.com/three@0.145.0/examples/jsm/"
-->
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "../../libs/three/build/three.module.js",
    "three/addons/": "../../libs/three/examples/jsm/",
    "libs/": "../../libs/"
  }
}
</script>
<script  type="module"> 
  import * as THREE from "three"
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
  import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { LoadingBar } from 'libs/LoadingBar.js';
  import { GUI } from "three/addons/libs/lil-gui.module.min.js"

  let scene, camera, renderer, clock, loadingBar, mixer, controls, ghoul;

  init();

  function init(){
    scene = new THREE.Scene();
    scene.background = new THREE.Color( 0xaaaaaa );
    
    camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );
    camera.position.set(0, 0.5, 3);
    
    clock = new THREE.Clock();

    const ambient = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 0.5);
    scene.add(ambient);
    
    const light = new THREE.DirectionalLight(0xFFFFFF, 1.5);
    light.position.set( 0.2, 1, 1 );
    scene.add(light);
    
    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setPixelRatio( Math.max(window.devicePixelRatio, 2) );
		renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.physicallyCorrectLights = true;
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );
    
    controls = new OrbitControls( camera, renderer.domElement );
    controls.target.y = 1;
    controls.update();

    setEnvironment();

    loadingBar = new LoadingBar(); 
        
    loadGhoul();
      
    window.addEventListener( 'resize', resize, false);
  }

  function setEnvironment(){
    const loader = new RGBELoader();
    const pmremGenerator = new THREE.PMREMGenerator( renderer );
    pmremGenerator.compileEquirectangularShader();
    
    loader.load( '../../assets/hdr/venice_sunset_1k.hdr', ( texture ) => {
      const envMap = pmremGenerator.fromEquirectangular( texture ).texture;
      pmremGenerator.dispose();

      scene.environment = envMap;

    }, undefined, (err)=>{
        console.error( 'An error occurred setting the environment.' + err.message );
    } );
  }
    
  function loadGhoul(){
        
    const loader = new GLTFLoader().setPath('../../assets/');
    
    const anims = [
          {start:81, end:161, name:"idle", loop:true},
          {start:250, end:290, name:"block", loop:false},
          {start:300, end:320, name:"gethit", loop:false},
          {start:340, end:375, name:"die", loop:false},
          {start:380, end:430, name:"attack", loop:false},
          {start:470, end:500, name:"walk", loop:true},
          {start:540, end:560, name:"run", loop:true}
        ];
    
    // Load a GLTF resource
    loader.load(
      // resource URL
      `ghoul.glb`,
      // called when the resource is loaded
      ( gltf ) => {
        const clip = gltf.animations[0];
        const animations = [];
        
        anims.forEach((anim)=>{
            animations.push( THREE.AnimationUtils.subclip(clip, anim.name, anim.start, anim.end) );
        });

        gltf.animations = animations;

        mixer = new THREE.AnimationMixer( gltf.scene );

        ghoul = gltf.scene;
        ghoul.rotateX( -Math.PI/2 );

        scene.add( ghoul );

        exportGLTF( ghoul, animations );

        const action = mixer.clipAction( animations[0] );
        action.play();

        loadingBar.visible = false;

        update();
      },
      // called while loading is progressing
      ( xhr ) => {

        loadingBar.progress = (xhr.loaded / xhr.total) * 0.33 + 0.33;

      },
      // called when loading has errors
      ( error ) => {

        console.error( error.message );

      }
    );
  }

  function exportGLTF( input, animations ) {

    const gltfExporter = new GLTFExporter();

    const options = {
      trs: true,
      onlyVisible: true,
      binary: true,
      maxTextureSize: 1024,
      animations
    };

    gltfExporter.parse(
      input,
      ( result ) => {

        if ( result instanceof ArrayBuffer ) {

          saveArrayBuffer( result, 'scene.glb' );

        } else {

          const output = JSON.stringify( result, null, 2 );
          console.log( output );
          saveString( output, 'scene.gltf' );
        }

      },
      ( error ) => {

        console.log( 'An error happened during parsing', error );

      },
      options
    );
  }

  const link = document.createElement( 'a' );
  link.style.display = 'none';
  document.body.appendChild( link ); // Firefox workaround, see #6594

  function save( blob, filename ) {

    link.href = URL.createObjectURL( blob );
    link.download = filename;
    link.click();

    // URL.revokeObjectURL( url ); breaks Firefox...
  }

  function saveString( text, filename ) {

    save( new Blob( [ text ], { type: 'text/plain' } ), filename );

  }


  function saveArrayBuffer( buffer, filename ) {

    save( new Blob( [ buffer ], { type: 'application/octet-stream' } ), filename );

  }

  function update(){
    requestAnimationFrame( update );
    const dt = clock.getDelta();
    mixer.update(dt);
    renderer.render( scene, camera );  
  }

  function resize(){
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize( window.innerWidth, window.innerHeight );
  }
</script>
</body>
</html>