<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>The Three.JS Cookbook: Physics - Joints</title>
  <link rel="apple-touch-icon" sizes="180x180" href="../../images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../../images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../../images/favicon/favicon-16x16.png">
  <link rel="manifest" href="../../site.webmanifest">
  <style>
    body{
      padding: 0;
      margin: 0;
    }
  </style>
</head>
<body>
<script type="importmap">
  {
    "imports": {
      "three": "../../node_modules/three/build/three.module.js",
      "three/addons/": "../../node_modules/three/examples/jsm/"
    }
  }
</script>
<script  type="module"> 
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js"
  import { RapierPhysics, RapierDebugRenderer } from '../../libs/RapierPhysics.js';
  
  let scene, camera, renderer, controls, movement, physics, debugRender, vehicleController, chassis, wheels;

init();

async function init(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color( 0xAAAAFF );

  camera = new THREE.PerspectiveCamera( 60, window.innerWidth/window.innerHeight, 0.1, 100 );
  camera.position.set(0, 4, 10);

  const ambient = new THREE.HemisphereLight(0x555555, 0xFFFFFF);
  scene.add(ambient);

  const light = new THREE.DirectionalLight(0xffffff, 4);
  light.position.set(5,12.5,12.5);
  light.castShadow = true;
  light.shadow.radius = 7;
  light.shadow.blurSamples = 8;
  light.shadow.mapSize.width = 1024; 
  light.shadow.mapSize.height = 1024; 
  const size = 10;
  light.shadow.camera.left = -size;
  light.shadow.camera.bottom = -size;
  light.shadow.camera.right = size;
  light.shadow.camera.top = size;
  light.shadow.camera.near = 1;
  light.shadow.camera.far = 50;

  scene.add(light);
  
  renderer = new THREE.WebGLRenderer();
  renderer.setSize( window.innerWidth, window.innerHeight );
  renderer.shadowMap.enabled = true;
  document.body.appendChild( renderer.domElement );

  controls = new OrbitControls(camera, renderer.domElement);
  controls.target = new THREE.Vector3(0, 2, 0);
  controls.update();

  const geometry = new THREE.BoxGeometry( 20, 0.5, 50 );
  const material = new THREE.MeshStandardMaterial( { color: 0xFFFFAA } );
  
  const ground = new THREE.Mesh( geometry, material );
  ground.receiveShadow = true;

  ground.position.set( 0, -0.25, -20 );
  ground.userData.physics = { mass: 0 };

  scene.add( ground);
  
  initPhysics();
  
  onWindowResize();

  window.addEventListener( 'resize', onWindowResize, false );

  // Movement input
  movement = { forward: 0, right: 0, brake: 0 };

  window.addEventListener("keydown", (event) => {
    //console.log( event.key );
    if (event.key === "w" || event.key === "ArrowUp") movement.forward = -1;
    if (event.key === "s" || event.key === "ArrowDown") movement.forward = 1;
    if (event.key === "a" || event.key === "ArrowLeft") movement.right = 1;
    if (event.key === "d" || event.key === "ArrowRight") movement.right = -1;
    if (event.key === "Space") movement.brake = 1;
  });

  window.addEventListener("keyup", (event) => {
    if (event.key === "w" || event.key === "s" || event.key === "ArrowUp" || event.key === "ArrowDown") movement.forward = 0;
    if (event.key === "a" || event.key === "d" || event.key === "ArrowLeft" || event.key === "ArrowRight") movement.right = 0;
    if (event.key === "Space") movement.brake = 0;
  });

  update();
}

async function initPhysics(){
	physics = await RapierPhysics();

  physics.addScene( scene );

  createCar();

  debugRender = new RapierDebugRenderer( scene, physics.world );

}

function createCar( ){

  const geometry = new THREE.BoxGeometry( 2, 1, 4 );
  const material = new THREE.MeshStandardMaterial( { color: 0xFF0000 } );
  const mesh = new THREE.Mesh( geometry, material );
  mesh.castShadow = true;
  scene.add( mesh );

  mesh.position.y = 1;
  chassis = physics.addMesh( mesh, 10, 0.8 );

  vehicleController = physics.world.createVehicleController( chassis );

  wheels = [];

  addWheel( 0, { x: -1, y: -0.5, z: -1.5 }, mesh );
  addWheel( 1, { x: 1, y: -0.5, z: -1.5 }, mesh );
  addWheel( 2, { x: -1, y: -0.5, z: 1.5 }, mesh );
  addWheel( 3, { x: 1, y: -0.5, z: 1.5 }, mesh );

  vehicleController.setWheelSteering(0, Math.PI/4);
  vehicleController.setWheelSteering(1, Math.PI/4);

}

function addWheel( index, pos, carMesh ){

  // Define wheel properties
  const wheelRadius = 0.3;
  const wheelWidth = 0.4;
  const wheelPosition = pos // Position relative to chassis
  const wheelDirection = { x: 0.0, y: -1.0, z: 0.0 }; // Downward direction
  const wheelAxle = { x: -1.0, y: 0.0, z: 0.0 }; // Axle direction

  // Add the wheel to the vehicle controller
  vehicleController.addWheel(
      wheelPosition,
      wheelDirection,
      wheelAxle,
      wheelRadius,
      wheelWidth,
      pos.z<0 // Indicates if this is a front wheel
  );

  // Set suspension stiffness for wheel
  vehicleController.setWheelSuspensionStiffness(index, 20.0);

  // Set wheel friction
  vehicleController.setWheelFrictionSlip(index, 1000.0);

  // Enable steering for the wheel
  vehicleController.setWheelSteering(index, pos.z<0);

  // Create a wheel mesh
  const geometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelWidth, 16);
  geometry.rotateZ( Math.PI * 0.5 )
  const material = new THREE.MeshStandardMaterial({ color: 0x000000 });
  const wheel = new THREE.Mesh(geometry, material);

  wheel.castShadow = true;

  wheel.position.copy( pos );

  // Rotate the wheel so it's aligned correctly
  //wheel.rotation.z = Math.PI / 2;

  wheels.push( wheel );
  carMesh.add( wheel );

}

function updateWheels() {
  if ( vehicleController === undefined ) return;

  const wheelSteeringQuat = new THREE.Quaternion();
  const wheelRotationQuat = new THREE.Quaternion();
  const up = new THREE.Vector3( 0, 1, 0 );

  //const chassisPosition = chassis.translation();

  wheels.forEach((wheel, index) => {
      const wheelAxleCs = vehicleController.wheelAxleCs(index);
      const connection = vehicleController.wheelChassisConnectionPointCs(index).y || 0;
      const suspension = vehicleController.wheelSuspensionLength(index) || 0;
      const steering = vehicleController.wheelSteering(index) || 0;
      const rotationRad = vehicleController.wheelRotation(index) || 0;

      wheel.position.y = connection - suspension;

      wheelSteeringQuat.setFromAxisAngle(up, steering);
      wheelRotationQuat.setFromAxisAngle(wheelAxleCs, rotationRad);

      wheel.quaternion.multiplyQuaternions( wheelSteeringQuat, wheelRotationQuat );
  })

}

function onWindowResize( event ) {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize( window.innerWidth, window.innerHeight );
}

function updateCarControl(){

  const engineForce = movement.forward * 10;

  vehicleController.setWheelEngineForce(0, engineForce);
  vehicleController.setWheelEngineForce(1, engineForce);

  const currentSteering = vehicleController.wheelSteering(0);
  const steerDirection = movement.right;
  const steerAngle = Math.PI/4;

  const steering = THREE.MathUtils.lerp(currentSteering, steerAngle * steerDirection, 0.5)

  vehicleController.setWheelSteering(0, steering);
  vehicleController.setWheelSteering(1, steering);

  const wheelBrake = movement.brake * 5;
  vehicleController.setWheelBrake(0, wheelBrake);
  vehicleController.setWheelBrake(1, wheelBrake);
  vehicleController.setWheelBrake(2, wheelBrake);
  vehicleController.setWheelBrake(3, wheelBrake);

}

function update() {
  requestAnimationFrame( update );
  if ( vehicleController ){
    updateCarControl();
    vehicleController.updateVehicle(1/60);
    updateWheels();
  }
  if (debugRender) debugRender.update();
  renderer.render( scene, camera );
} 
  
</script>

</body>
</html>